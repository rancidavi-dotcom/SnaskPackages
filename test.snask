import "log";
import "os";
import "json";

// test.snask — mini framework de testes (Snask puro)
// Uso recomendado:
//   test::begin();
//   test::check("nome", cond);
//   test::assert_eq("x", a, b);
//   test::end(); // exit(1) se falhar

mut _tests_total = 0;
mut _tests_ok = 0;
mut _tests_fail = 0;
mut _tests_skip = 0;
mut _tests_todo = 0;
mut _tests_exit_on_fail = false;
mut _tests_section = "";
mut _tests_started_at = 0;
mut _tests_snap_dir = "__snapshots__";
mut _tests_update_snapshots = false;
mut _tests_failed_names = nil; // json object { "0": "name", ... }
mut _tests_failed_len = 0;

fun begin()
    _tests_total = 0;
    _tests_ok = 0;
    _tests_fail = 0;
    _tests_skip = 0;
    _tests_todo = 0;
    _tests_section = "";
    _tests_started_at = os::now();
    _tests_failed_names = nil;
    _tests_failed_len = 0;
    log::info("tests: begin");
    return true;

fun total()
    return _tests_total;

fun passed()
    return _tests_ok;

fun failed()
    return _tests_fail;

fun skipped()
    return _tests_skip;

fun todo_count()
    return _tests_todo;

fun set_exit_on_fail(on)
    _tests_exit_on_fail = on;
    return true;

fun get_exit_on_fail()
    return _tests_exit_on_fail;

fun section(name)
    _tests_section = name;
    log::info("section: " + name);
    return true;

fun clear_section()
    _tests_section = "";
    return true;

fun set_snapshots_dir(dir)
    _tests_snap_dir = dir;
    return true;

fun snapshots_dir()
    return _tests_snap_dir;

fun enable_update_snapshots(on)
    _tests_update_snapshots = on;
    return true;

fun is_update_snapshots_enabled()
    return _tests_update_snapshots;

fun _name(name)
    if is_nil(_tests_section)
        return name;
    if _tests_section == ""
        return name;
    return _tests_section + " :: " + name;

fun _fail_push(name)
    if is_nil(_tests_failed_names)
        _tests_failed_names = json::new_object();
        _tests_failed_len = 0;
    json::set(_tests_failed_names, num_to_str(_tests_failed_len), _name(name));
    _tests_failed_len = _tests_failed_len + 1;
    return true;

fun failed_names()
    return _tests_failed_names;

fun _ok(name)
    _tests_total = _tests_total + 1;
    _tests_ok = _tests_ok + 1;
    log::info("PASS " + _name(name));
    return true;

fun _fail(name, msg)
    _tests_total = _tests_total + 1;
    _tests_fail = _tests_fail + 1;
    log::error("FAIL " + _name(name) + " :: " + msg);
    _fail_push(name);
    if _tests_exit_on_fail
        exit(1);
    return false;

fun _skip(name, msg)
    _tests_total = _tests_total + 1;
    _tests_skip = _tests_skip + 1;
    log::warn("SKIP " + _name(name) + " :: " + msg);
    return true;

fun _todo(name, msg)
    _tests_total = _tests_total + 1;
    _tests_todo = _tests_todo + 1;
    log::warn("TODO " + _name(name) + " :: " + msg);
    return true;

fun check(name, cond)
    if cond
        return _ok(name);
    return _fail(name, "cond=false");

fun assert(name, cond)
    // assert é igual check, mas encerra em caso de falha
    if cond
        return _ok(name);
    _fail(name, "assertion failed");
    exit(1);
    return false;

fun assert_eq(name, a, b)
    if a == b
        return _ok(name);
    return _fail(name, "expected eq");

fun assert_ne(name, a, b)
    if a != b
        return _ok(name);
    return _fail(name, "expected ne");

fun assert_true(name, v)
    if v
        return _ok(name);
    return _fail(name, "expected true");

fun assert_false(name, v)
    if not v
        return _ok(name);
    return _fail(name, "expected false");

fun assert_nil(name, v)
    if is_nil(v)
        return _ok(name);
    return _fail(name, "expected nil");

fun assert_not_nil(name, v)
    if not is_nil(v)
        return _ok(name);
    return _fail(name, "expected not nil");

fun skip(name, msg)
    return _skip(name, msg);

fun todo(name, msg)
    return _todo(name, msg);

fun fail(name, msg)
    return _fail(name, msg);

fun pass(name)
    return _ok(name);

fun check_eq(name, a, b)
    return assert_eq(name, a, b);

fun check_ne(name, a, b)
    return assert_ne(name, a, b);

fun check_true(name, v)
    return assert_true(name, v);

fun check_false(name, v)
    return assert_false(name, v);

fun check_nil(name, v)
    return assert_nil(name, v);

fun check_not_nil(name, v)
    return assert_not_nil(name, v);

fun assert_lt(name, a, b)
    if a < b
        return _ok(name);
    return _fail(name, "expected a < b");

fun assert_le(name, a, b)
    if a <= b
        return _ok(name);
    return _fail(name, "expected a <= b");

fun assert_gt(name, a, b)
    if a > b
        return _ok(name);
    return _fail(name, "expected a > b");

fun assert_ge(name, a, b)
    if a >= b
        return _ok(name);
    return _fail(name, "expected a >= b");

fun check_lt(name, a, b)
    return assert_lt(name, a, b);

fun check_le(name, a, b)
    return assert_le(name, a, b);

fun check_gt(name, a, b)
    return assert_gt(name, a, b);

fun check_ge(name, a, b)
    return assert_ge(name, a, b);

fun assert_between(name, x, lo, hi)
    if x >= lo and x <= hi
        return _ok(name);
    return _fail(name, "expected lo <= x <= hi");

fun check_between(name, x, lo, hi)
    return assert_between(name, x, lo, hi);

fun assert_str(name, v)
    if is_str(v)
        return _ok(name);
    return _fail(name, "expected string");

fun assert_obj(name, v)
    if is_obj(v)
        return _ok(name);
    return _fail(name, "expected object");

fun check_str(name, v)
    return assert_str(name, v);

fun check_obj(name, v)
    return assert_obj(name, v);

fun summary()
    return "total=" + num_to_str(_tests_total) + " ok=" + num_to_str(_tests_ok) + " fail=" + num_to_str(_tests_fail) + " skip=" + num_to_str(_tests_skip) + " todo=" + num_to_str(_tests_todo);

fun duration_s()
    let now = os::now();
    return now - _tests_started_at;

fun report()
    return "tests: " + summary() + " duration_s=" + num_to_str(duration_s());

fun ok()
    return _tests_fail == 0;

fun has_failures()
    return _tests_fail > 0;

fun end()
    log::info(report());
    if _tests_fail > 0
        exit(1);
    return true;

// ---------------- Snapshots ----------------
fun _snap_file(name)
    return _tests_snap_dir + "/" + name + ".snap";

fun snapshot(name, value_str)
    sfs_mkdir(_tests_snap_dir);
    let p = _snap_file(name);
    if _tests_update_snapshots or not sfs_exists(p)
        sfs_write(p, value_str);
        return _ok("snapshot: " + name);
    let cur = sfs_read(p);
    if cur == value_str
        return _ok("snapshot: " + name);
    return _fail("snapshot: " + name, "snapshot mismatch");

fun snapshot_update(name, value_str)
    let prev = _tests_update_snapshots;
    _tests_update_snapshots = true;
    let r = snapshot(name, value_str);
    _tests_update_snapshots = prev;
    return r;
