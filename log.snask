import "os";
import "sfs";
import "json";

// log.snask — logging simples (Snask puro)
// Níveis: 0=debug, 1=info, 2=warn, 3=error, 4=off

mut _log_level = 1;
// se string, também escreve no arquivo (append)
mut _log_file = nil;
mut _log_with_time = true;
mut _log_prefix = "";
mut _log_sep = " ";
mut _log_console = true;
mut _log_buffer_enabled = false;
// json object: {"0":"...", "1":"..."}
mut _log_buffer = nil;
mut _log_buffer_len = 0;
// json object: {"request_id":"...", ...}
mut _log_fields = nil;
// 0 desliga
mut _log_rotate_max_bytes = 0;
// 0 desliga
mut _log_rotate_keep = 0;

fun level_debug()
    return 0;

fun level_info()
    return 1;

fun level_warn()
    return 2;

fun level_error()
    return 3;

fun level_off()
    return 4;

fun set_level(level)
    log::_log_level = level;
    return true;

fun get_level()
    return log::_log_level;

fun set_prefix(prefix)
    log::_log_prefix = prefix;
    return true;

fun get_prefix()
    return log::_log_prefix;

fun set_separator(sep)
    log::_log_sep = sep;
    return true;

fun get_separator()
    return log::_log_sep;

fun set_file(path)
    log::_log_file = path;
    return true;

fun clear_file()
    log::_log_file = nil;
    return true;

fun set_rotate(max_bytes, keep_files)
    // Ex: set_rotate(1000000, 3) -> app.log, app.log.1, app.log.2, app.log.3
    log::_log_rotate_max_bytes = max_bytes;
    log::_log_rotate_keep = keep_files;
    return true;

fun clear_rotate()
    log::_log_rotate_max_bytes = 0;
    log::_log_rotate_keep = 0;
    return true;

fun enable_console(on)
    log::_log_console = on;
    return true;

fun is_console_enabled()
    return log::_log_console;

fun enable_time(on)
    log::_log_with_time = on;
    return true;

fun is_time_enabled()
    return log::_log_with_time;

fun enable_buffer(on)
    log::_log_buffer_enabled = on;
    if on and is_nil(log::_log_buffer)
        log::_log_buffer = json::new_object();
        log::_log_buffer_len = 0;
    return true;

fun is_buffer_enabled()
    return log::_log_buffer_enabled;

fun clear_buffer()
    log::_log_buffer = json::new_object();
    log::_log_buffer_len = 0;
    return true;

fun buffer_len()
    return log::_log_buffer_len;

fun buffer_get(idx)
    if is_nil(log::_log_buffer)
        return nil;
    return json::get(log::_log_buffer, num_to_str(idx));

fun buffer_all()
    return log::_log_buffer;

fun set_field(key, value)
    if is_nil(log::_log_fields)
        log::_log_fields = json::new_object();
    json::set(log::_log_fields, key, value);
    return true;

fun clear_field(key)
    if is_nil(log::_log_fields)
        return true;
    json::set(log::_log_fields, key, nil);
    return true;

fun clear_fields()
    log::_log_fields = json::new_object();
    return true;

fun fields()
    if is_nil(log::_log_fields)
        log::_log_fields = json::new_object();
    return log::_log_fields;

fun level_name(level)
    if level == 0
        return "DEBUG";
    if level == 1
        return "INFO";
    if level == 2
        return "WARN";
    if level == 3
        return "ERROR";
    return "OFF";

fun _ts()
    if not log::_log_with_time
        return "";
    // epoch seconds
    let t = os::now();
    return "[" + num_to_str(t) + "]";

fun _prefix()
    if is_nil(log::_log_prefix)
        return "";
    if log::_log_prefix == ""
        return "";
    return log::_log_prefix;

fun _fields_str()
    if is_nil(log::_log_fields)
        return "";
    // stringify é suficiente; para logs humanos, vai como objeto em JSON.
    let s = json::stringify(log::_log_fields);
    if s == "{}"
        return "";
    return s;

fun _line(level, message)
    let tag = log::level_name(level);
    let p = log::_prefix();
    let f = log::_fields_str();
    if p == "" and f == ""
        return log::_ts() + log::_log_sep + tag + log::_log_sep + message;
    if p != "" and f == ""
        return log::_ts() + log::_log_sep + tag + log::_log_sep + p + log::_log_sep + message;
    if p == "" and f != ""
        return log::_ts() + log::_log_sep + tag + log::_log_sep + f + log::_log_sep + message;
    return log::_ts() + log::_log_sep + tag + log::_log_sep + p + log::_log_sep + f + log::_log_sep + message;

fun _rotate_if_needed()
    if is_nil(log::_log_file)
        return false;
    if log::_log_rotate_max_bytes <= 0 or log::_log_rotate_keep <= 0
        return false;
    if not sfs::exists(log::_log_file)
        return false;
    let sz = sfs_size(log::_log_file);
    if sz < log::_log_rotate_max_bytes
        return false;

    // rotate: .(keep..1)
    mut i = log::_log_rotate_keep;
    while i >= 1
        mut src = log::_log_file;
        if i > 1
            src = log::_log_file + "." + num_to_str(i - 1);
        let dst = log::_log_file + "." + num_to_str(i);
        if sfs::exists(src)
            sfs_move(src, dst);
        i = i - 1;
    // truncate original
    sfs::write(log::_log_file, "");
    return true;

fun _emit(line)
    if log::_log_console
        print(line);
    if not is_nil(log::_log_file)
        log::_rotate_if_needed();
        sfs::append(log::_log_file, line + "\n");
    if log::_log_buffer_enabled
        if is_nil(log::_log_buffer)
            log::_log_buffer = json::new_object();
        json::set(log::_log_buffer, num_to_str(log::_log_buffer_len), line);
        log::_log_buffer_len = log::_log_buffer_len + 1;
    return true;

fun log(level, message)
    if log::_log_level == 4
        return false;
    if level < log::_log_level
        return false;
    return log::_emit(log::_line(level, message));

fun debug(message)
    return log::log(0, message);

fun info(message)
    return log::log(1, message);

fun warn(message)
    return log::log(2, message);

fun error(message)
    return log::log(3, message);

fun fatal(message)
    log::log(3, message);
    exit(1);
    return false;

fun debug2(a, b)
    return log::debug(a + log::_log_sep + b);

fun info2(a, b)
    return log::info(a + log::_log_sep + b);

fun warn2(a, b)
    return log::warn(a + log::_log_sep + b);

fun error2(a, b)
    return log::error(a + log::_log_sep + b);

fun debug3(a, b, c)
    return log::debug(a + log::_log_sep + b + log::_log_sep + c);

fun info3(a, b, c)
    return log::info(a + log::_log_sep + b + log::_log_sep + c);

fun warn3(a, b, c)
    return log::warn(a + log::_log_sep + b + log::_log_sep + c);

fun error3(a, b, c)
    return log::error(a + log::_log_sep + b + log::_log_sep + c);

fun kv(level, key, value)
    return log::log(level, key + "=" + value);

fun kv_info(key, value)
    return log::kv(1, key, value);

fun kv_warn(key, value)
    return log::kv(2, key, value);

fun kv_error(key, value)
    return log::kv(3, key, value);

fun kv_debug(key, value)
    return log::kv(0, key, value);

fun info_kv(key, value)
    return log::kv_info(key, value);

fun warn_kv(key, value)
    return log::kv_warn(key, value);

fun error_kv(key, value)
    return log::kv_error(key, value);

fun debug_kv(key, value)
    return log::kv_debug(key, value);

fun kv_num(level, key, n)
    return log::log(level, key + "=" + num_to_str(n));

fun kv_bool(level, key, b)
    if b
        return log::log(level, key + "=true");
    return log::log(level, key + "=false");

fun kv_any(level, key, v)
    // fallback: stringify via json (pode virar string/num/bool/obj)
    let s = json::stringify(v);
    return log::log(level, key + "=" + s);

fun info_json(label, v)
    let s = json::stringify(v);
    return log::info(label + log::_log_sep + s);

fun warn_json(label, v)
    let s = json::stringify(v);
    return log::warn(label + log::_log_sep + s);

fun error_json(label, v)
    let s = json::stringify(v);
    return log::error(label + log::_log_sep + s);

fun debug_json(label, v)
    let s = json::stringify(v);
    return log::debug(label + log::_log_sep + s);

fun with_level(level, message)
    // helper: log respeitando filtro
    return log::log(level, message);

fun temporarily_set_level(level)
    let prev = log::_log_level;
    log::_log_level = level;
    return prev;

fun restore_level(prev)
    log::_log_level = prev;
    return true;

fun trace(message)
    // alias de debug (para quem prefere)
    return log::debug(message);

fun notice(message)
    // alias de info
    return log::info(message);

fun panic(message)
    // alias de fatal
    return log::fatal(message);

fun to_file(path, message)
    // util: escreve log direto num arquivo sem mexer no estado global
    sfs::append(path, message + "\n");
    return true;

fun open_session(prefix)
    log::set_prefix(prefix);
    return true;

fun close_session()
    log::set_prefix("");
    return true;

fun capture_begin()
    // habilita buffer e limpa
    log::enable_buffer(true);
    log::clear_buffer();
    return true;

fun capture_end()
    // retorna snapshot do buffer (obj)
    let b = log::buffer_all();
    log::enable_buffer(false);
    return b;
