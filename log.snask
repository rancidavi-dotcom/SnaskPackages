import "os";
import "sfs";
import "json";

// log.snask — logging simples (Snask puro)
// Níveis: 0=debug, 1=info, 2=warn, 3=error, 4=off

mut _log_level = 1;
// se string, também escreve no arquivo (append)
mut _log_file = nil;
mut _log_with_time = true;
mut _log_prefix = "";
mut _log_sep = " ";
mut _log_console = true;
mut _log_buffer_enabled = false;
// json object: {"0":"...", "1":"..."}
mut _log_buffer = nil;
mut _log_buffer_len = 0;
// json object: {"request_id":"...", ...}
mut _log_fields = nil;
// 0 desliga
mut _log_rotate_max_bytes = 0;
// 0 desliga
mut _log_rotate_keep = 0;

fun level_debug()
    return 0;

fun level_info()
    return 1;

fun level_warn()
    return 2;

fun level_error()
    return 3;

fun level_off()
    return 4;

fun set_level(level)
    _log_level = level;
    return true;

fun get_level()
    return _log_level;

fun set_prefix(prefix)
    _log_prefix = prefix;
    return true;

fun get_prefix()
    return _log_prefix;

fun set_separator(sep)
    _log_sep = sep;
    return true;

fun get_separator()
    return _log_sep;

fun set_file(path)
    _log_file = path;
    return true;

fun clear_file()
    _log_file = nil;
    return true;

fun set_rotate(max_bytes, keep_files)
    // Ex: set_rotate(1000000, 3) -> app.log, app.log.1, app.log.2, app.log.3
    _log_rotate_max_bytes = max_bytes;
    _log_rotate_keep = keep_files;
    return true;

fun clear_rotate()
    _log_rotate_max_bytes = 0;
    _log_rotate_keep = 0;
    return true;

fun enable_console(on)
    _log_console = on;
    return true;

fun is_console_enabled()
    return _log_console;

fun enable_time(on)
    _log_with_time = on;
    return true;

fun is_time_enabled()
    return _log_with_time;

fun enable_buffer(on)
    _log_buffer_enabled = on;
    if on and is_nil(_log_buffer)
        _log_buffer = json::new_object();
        _log_buffer_len = 0;
    return true;

fun is_buffer_enabled()
    return _log_buffer_enabled;

fun clear_buffer()
    _log_buffer = json::new_object();
    _log_buffer_len = 0;
    return true;

fun buffer_len()
    return _log_buffer_len;

fun buffer_get(idx)
    if is_nil(_log_buffer)
        return nil;
    return json::get(_log_buffer, num_to_str(idx));

fun buffer_all()
    return _log_buffer;

fun set_field(key, value)
    if is_nil(_log_fields)
        _log_fields = json::new_object();
    json::set(_log_fields, key, value);
    return true;

fun clear_field(key)
    if is_nil(_log_fields)
        return true;
    json::set(_log_fields, key, nil);
    return true;

fun clear_fields()
    _log_fields = json::new_object();
    return true;

fun fields()
    if is_nil(_log_fields)
        _log_fields = json::new_object();
    return _log_fields;

fun level_name(level)
    if level == 0
        return "DEBUG";
    if level == 1
        return "INFO";
    if level == 2
        return "WARN";
    if level == 3
        return "ERROR";
    return "OFF";

fun _ts()
    if not _log_with_time
        return "";
    // epoch seconds
    let t = os::now();
    return "[" + num_to_str(t) + "]";

fun _prefix()
    if is_nil(_log_prefix)
        return "";
    if _log_prefix == ""
        return "";
    return _log_prefix;

fun _fields_str()
    if is_nil(_log_fields)
        return "";
    // stringify é suficiente; para logs humanos, vai como objeto em JSON.
    let s = json::stringify(_log_fields);
    if s == "{}"
        return "";
    return s;

fun _line(level, message)
    let tag = level_name(level);
    let p = _prefix();
    let f = _fields_str();
    if p == "" and f == ""
        return _ts() + _log_sep + tag + _log_sep + message;
    if p != "" and f == ""
        return _ts() + _log_sep + tag + _log_sep + p + _log_sep + message;
    if p == "" and f != ""
        return _ts() + _log_sep + tag + _log_sep + f + _log_sep + message;
    return _ts() + _log_sep + tag + _log_sep + p + _log_sep + f + _log_sep + message;

fun _rotate_if_needed()
    if is_nil(_log_file)
        return false;
    if _log_rotate_max_bytes <= 0 or _log_rotate_keep <= 0
        return false;
    if not sfs::exists(_log_file)
        return false;
    let sz = sfs_size(_log_file);
    if sz < _log_rotate_max_bytes
        return false;

    // rotate: .(keep..1)
    let i = _log_rotate_keep;
    while i >= 1
        let src = _log_file;
        if i > 1
            src = _log_file + "." + num_to_str(i - 1);
        let dst = _log_file + "." + num_to_str(i);
        if sfs::exists(src)
            sfs_move(src, dst);
        i = i - 1;
    // truncate original
    sfs::write(_log_file, "");
    return true;

fun _emit(line)
    if _log_console
        print(line);
    if not is_nil(_log_file)
        _rotate_if_needed();
        sfs::append(_log_file, line + "\n");
    if _log_buffer_enabled
        if is_nil(_log_buffer)
            _log_buffer = json::new_object();
        json::set(_log_buffer, num_to_str(_log_buffer_len), line);
        _log_buffer_len = _log_buffer_len + 1;
    return true;

fun log(level, message)
    if _log_level == 4
        return false;
    if level < _log_level
        return false;
    return _emit(_line(level, message));

fun debug(message)
    return log(0, message);

fun info(message)
    return log(1, message);

fun warn(message)
    return log(2, message);

fun error(message)
    return log(3, message);

fun fatal(message)
    log(3, message);
    exit(1);
    return false;

fun debug2(a, b)
    return debug(a + _log_sep + b);

fun info2(a, b)
    return info(a + _log_sep + b);

fun warn2(a, b)
    return warn(a + _log_sep + b);

fun error2(a, b)
    return error(a + _log_sep + b);

fun debug3(a, b, c)
    return debug(a + _log_sep + b + _log_sep + c);

fun info3(a, b, c)
    return info(a + _log_sep + b + _log_sep + c);

fun warn3(a, b, c)
    return warn(a + _log_sep + b + _log_sep + c);

fun error3(a, b, c)
    return error(a + _log_sep + b + _log_sep + c);

fun kv(level, key, value)
    return log(level, key + "=" + value);

fun kv_info(key, value)
    return kv(1, key, value);

fun kv_warn(key, value)
    return kv(2, key, value);

fun kv_error(key, value)
    return kv(3, key, value);

fun kv_debug(key, value)
    return kv(0, key, value);

fun info_kv(key, value)
    return kv_info(key, value);

fun warn_kv(key, value)
    return kv_warn(key, value);

fun error_kv(key, value)
    return kv_error(key, value);

fun debug_kv(key, value)
    return kv_debug(key, value);

fun kv_num(level, key, n)
    return log(level, key + "=" + num_to_str(n));

fun kv_bool(level, key, b)
    if b
        return log(level, key + "=true");
    return log(level, key + "=false");

fun kv_any(level, key, v)
    // fallback: stringify via json (pode virar string/num/bool/obj)
    let s = json::stringify(v);
    return log(level, key + "=" + s);

fun info_json(label, v)
    let s = json::stringify(v);
    return info(label + _log_sep + s);

fun warn_json(label, v)
    let s = json::stringify(v);
    return warn(label + _log_sep + s);

fun error_json(label, v)
    let s = json::stringify(v);
    return error(label + _log_sep + s);

fun debug_json(label, v)
    let s = json::stringify(v);
    return debug(label + _log_sep + s);

fun with_level(level, message)
    // helper: log respeitando filtro
    return log(level, message);

fun temporarily_set_level(level)
    let prev = _log_level;
    _log_level = level;
    return prev;

fun restore_level(prev)
    _log_level = prev;
    return true;

fun trace(message)
    // alias de debug (para quem prefere)
    return debug(message);

fun notice(message)
    // alias de info
    return info(message);

fun panic(message)
    // alias de fatal
    return fatal(message);

fun to_file(path, message)
    // util: escreve log direto num arquivo sem mexer no estado global
    sfs::append(path, message + "\n");
    return true;

fun open_session(prefix)
    set_prefix(prefix);
    return true;

fun close_session()
    set_prefix("");
    return true;

fun capture_begin()
    // habilita buffer e limpa
    enable_buffer(true);
    clear_buffer();
    return true;

fun capture_end()
    // retorna snapshot do buffer (obj)
    let b = buffer_all();
    enable_buffer(false);
    return b;
